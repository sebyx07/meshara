# POST-MVP PHASE 3: LANGUAGE BINDINGS

## Overview

Provide first-class support for popular programming languages beyond Rust. Enable developers in Python, JavaScript, Go, and C/C++ to use Meshara with idiomatic APIs.

**Objective**: Publish official bindings for Python, JavaScript (Node.js), Go, and C with comprehensive examples.

---

## Architecture

### C FFI Foundation

**All bindings build on C FFI** (Foreign Function Interface):

```
Rust Core → C FFI → Language Bindings → Developer Applications
```

**Benefits**:
- Single FFI layer for all languages
- Stable ABI (C is universally supported)
- Easier maintenance

---

## C FFI Layer

### Header Generation with cbindgen

**Cargo.toml**:
```toml
[build-dependencies]
cbindgen = "0.26"
```

**build.rs**:
```rust
fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_no_includes()
        .with_sys_include("stdint.h")
        .with_sys_include("stdbool.h")
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file("target/meshara.h");
}
```

**Example C API** (src/ffi/c_api.rs):
```rust
use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_void};

#[repr(C)]
pub struct MesharaNode {
    _private: [u8; 0],
}

#[no_mangle]
pub extern "C" fn meshara_node_create(config_json: *const c_char) -> *mut MesharaNode {
    let config_str = unsafe { CStr::from_ptr(config_json).to_str().unwrap() };

    let node = match Node::from_config_json(config_str) {
        Ok(n) => Box::new(n),
        Err(_) => return std::ptr::null_mut(),
    };

    Box::into_raw(node) as *mut MesharaNode
}

#[no_mangle]
pub extern "C" fn meshara_node_destroy(node: *mut MesharaNode) {
    if !node.is_null() {
        unsafe {
            let _ = Box::from_raw(node as *mut Node);
        }
    }
}

#[no_mangle]
pub extern "C" fn meshara_node_send_message(
    node: *mut MesharaNode,
    recipient: *const c_char,
    message: *const u8,
    message_len: usize,
) -> *mut c_char {
    let node = unsafe { &mut *(node as *mut Node) };
    let recipient_str = unsafe { CStr::from_ptr(recipient).to_str().unwrap() };
    let message_slice = unsafe { std::slice::from_raw_parts(message, message_len) };

    match node.send_message(recipient_str, message_slice) {
        Ok(msg_id) => CString::new(msg_id.to_string()).unwrap().into_raw(),
        Err(_) => std::ptr::null_mut(),
    }
}
```

---

## Python Bindings

### Using CFFI

**Installation**:
```bash
pip install meshara
```

**Implementation** (python/meshara/__init__.py):
```python
from cffi import FFI
import json

ffi = FFI()

# Load C definitions
ffi.cdef("""
    typedef struct MesharaNode MesharaNode;

    MesharaNode* meshara_node_create(const char* config_json);
    void meshara_node_destroy(MesharaNode* node);
    char* meshara_node_send_message(MesharaNode* node, const char* recipient, const uint8_t* message, size_t len);
""")

# Load shared library
lib = ffi.dlopen("libmeshara.so")

class MesharaNode:
    def __init__(self, config):
        config_json = json.dumps(config)
        self._handle = lib.meshara_node_create(config_json.encode('utf-8'))
        if self._handle == ffi.NULL:
            raise RuntimeError("Failed to create Meshara node")

    def __del__(self):
        if hasattr(self, '_handle') and self._handle:
            lib.meshara_node_destroy(self._handle)

    def send_message(self, recipient: str, message: bytes) -> str:
        msg_id_ptr = lib.meshara_node_send_message(
            self._handle,
            recipient.encode('utf-8'),
            message,
            len(message)
        )

        if msg_id_ptr == ffi.NULL:
            raise RuntimeError("Failed to send message")

        msg_id = ffi.string(msg_id_ptr).decode('utf-8')
        return msg_id

    def on_message(self, callback):
        # Callback registration
        @ffi.callback("void(const char*, const uint8_t*, size_t)")
        def c_callback(sender, message, message_len):
            sender_str = ffi.string(sender).decode('utf-8')
            message_bytes = bytes(ffi.buffer(message, message_len))
            callback(sender_str, message_bytes)

        lib.meshara_node_set_callback(self._handle, c_callback)

# Example usage
if __name__ == "__main__":
    node = MesharaNode({
        "bind_address": "0.0.0.0:8000",
        "storage_path": "/tmp/meshara"
    })

    def handle_message(sender, message):
        print(f"Message from {sender}: {message.decode('utf-8')}")

    node.on_message(handle_message)

    node.send_message("recipient_id", b"Hello, Meshara!")
```

**setup.py**:
```python
from setuptools import setup, find_packages

setup(
    name="meshara",
    version="0.1.0",
    packages=find_packages(),
    install_requires=["cffi>=1.15.0"],
    package_data={
        "meshara": ["*.so", "*.dylib", "*.dll"],
    },
    python_requires=">=3.8",
)
```

---

## JavaScript/Node.js Bindings

### Using napi-rs

**Cargo.toml**:
```toml
[dependencies]
napi = "2.14"
napi-derive = "2.14"

[lib]
crate-type = ["cdylib"]
```

**Implementation** (src/node_bindings.rs):
```rust
use napi::bindgen_prelude::*;
use napi_derive::napi;

#[napi]
pub struct MesharaNode {
    inner: Node,
}

#[napi]
impl MesharaNode {
    #[napi(constructor)]
    pub fn new(config: serde_json::Value) -> Result<Self> {
        let node = Node::from_config(config)
            .map_err(|e| Error::from_reason(e.to_string()))?;

        Ok(MesharaNode { inner: node })
    }

    #[napi]
    pub async fn send_message(&self, recipient: String, message: Buffer) -> Result<String> {
        self.inner
            .send_message(&recipient, &message)
            .await
            .map(|id| id.to_string())
            .map_err(|e| Error::from_reason(e.to_string()))
    }

    #[napi]
    pub fn on_message(&self, callback: JsFunction) -> Result<()> {
        let tsfn: ThreadsafeFunction<Message> = callback.create_threadsafe_function(0, |ctx| {
            Ok(vec![ctx.value])
        })?;

        self.inner.set_message_callback(move |msg| {
            tsfn.call(Ok(msg), napi::threadsafe_function::ThreadsafeFunctionCallMode::Blocking);
        });

        Ok(())
    }
}
```

**TypeScript Definitions** (index.d.ts):
```typescript
export interface NodeConfig {
  bindAddress?: string;
  storagePath: string;
  bootstrapNodes?: string[];
}

export class MesharaNode {
  constructor(config: NodeConfig);
  sendMessage(recipient: string, message: Buffer): Promise<string>;
  onMessage(callback: (sender: string, message: Buffer) => void): void;
}
```

**package.json**:
```json
{
  "name": "meshara",
  "version": "0.1.0",
  "main": "index.js",
  "types": "index.d.ts",
  "napi": {
    "name": "meshara",
    "triples": {
      "defaults": true,
      "additional": [
        "x86_64-unknown-linux-musl",
        "aarch64-unknown-linux-gnu",
        "armv7-unknown-linux-gnueabihf"
      ]
    }
  },
  "scripts": {
    "build": "napi build --platform --release",
    "prepublishOnly": "napi prepublish -t npm"
  }
}
```

**Usage Example**:
```javascript
const { MesharaNode } = require('meshara');

const node = new MesharaNode({
  storagePath: '/tmp/meshara'
});

node.onMessage((sender, message) => {
  console.log(`Message from ${sender}: ${message.toString()}`);
});

await node.sendMessage('recipient_id', Buffer.from('Hello, Meshara!'));
```

---

## Go Bindings

### Using cgo

**meshara.go**:
```go
package meshara

/*
#cgo LDFLAGS: -L. -lmeshara
#include "meshara.h"
#include <stdlib.h>
*/
import "C"
import (
    "encoding/json"
    "unsafe"
)

type Node struct {
    handle *C.MesharaNode
}

type Config struct {
    BindAddress    string   `json:"bind_address"`
    StoragePath    string   `json:"storage_path"`
    BootstrapNodes []string `json:"bootstrap_nodes,omitempty"`
}

func NewNode(config Config) (*Node, error) {
    configJSON, err := json.Marshal(config)
    if err != nil {
        return nil, err
    }

    cConfig := C.CString(string(configJSON))
    defer C.free(unsafe.Pointer(cConfig))

    handle := C.meshara_node_create(cConfig)
    if handle == nil {
        return nil, fmt.Errorf("failed to create node")
    }

    return &Node{handle: handle}, nil
}

func (n *Node) Close() {
    if n.handle != nil {
        C.meshara_node_destroy(n.handle)
        n.handle = nil
    }
}

func (n *Node) SendMessage(recipient string, message []byte) (string, error) {
    cRecipient := C.CString(recipient)
    defer C.free(unsafe.Pointer(cRecipient))

    cMessagePtr := (*C.uint8_t)(unsafe.Pointer(&message[0]))
    cMessageLen := C.size_t(len(message))

    msgIDPtr := C.meshara_node_send_message(n.handle, cRecipient, cMessagePtr, cMessageLen)
    if msgIDPtr == nil {
        return "", fmt.Errorf("failed to send message")
    }
    defer C.free(unsafe.Pointer(msgIDPtr))

    return C.GoString(msgIDPtr), nil
}
```

**Usage Example**:
```go
package main

import (
    "fmt"
    "github.com/meshara/meshara-go"
)

func main() {
    node, err := meshara.NewNode(meshara.Config{
        StoragePath: "/tmp/meshara",
    })
    if err != nil {
        panic(err)
    }
    defer node.Close()

    msgID, err := node.SendMessage("recipient_id", []byte("Hello, Meshara!"))
    if err != nil {
        panic(err)
    }

    fmt.Println("Message sent:", msgID)
}
```

---

## Distribution

### Package Managers

**Python (PyPI)**:
```bash
python setup.py sdist bdist_wheel
twine upload dist/*
```

**JavaScript (npm)**:
```bash
npm publish
```

**Go (Go modules)**:
```bash
git tag v0.1.0
git push origin v0.1.0
```

### Pre-built Binaries

**Release Strategy**:
- Build for multiple platforms (Linux, macOS, Windows)
- Architecture variants (x86_64, ARM64, ARMv7)
- Distribute via GitHub Releases
- Automatic CI/CD builds

---

## Success Criteria

**Language Bindings Complete When**:
- ✓ C FFI layer complete and documented
- ✓ Python bindings published to PyPI
- ✓ JavaScript bindings published to npm
- ✓ Go bindings available via Go modules
- ✓ Example projects for each language
- ✓ API documentation for each language
- ✓ CI/CD builds and tests all bindings
- ✓ 90%+ feature parity with Rust API

---

**Last Updated**: 2025-12-23
**Owner**: Developer Relations Team
**Status**: Planning
**Prerequisites**: MVP complete, Phase 1-2 complete
**Estimated Duration**: 6-8 weeks
**Budget**: $60,000 - $80,000

syntax = "proto3";

package meshara;

// Base message wrapper for all Meshara messages
message BaseMessage {
    uint32 version = 1;
    bytes message_id = 2;
    MessageType message_type = 3;
    int64 timestamp = 4;
    bytes sender_public_key = 5;
    bytes payload = 6;
    bytes signature = 7;
    optional RoutingInfo routing_info = 8;
}

// Message type enumeration
enum MessageType {
    BROADCAST = 0;
    PRIVATE_MESSAGE = 1;
    UPDATE_PACKAGE = 2;
    QUERY = 3;
    RESPONSE = 4;
    ROUTE_ADVERTISEMENT = 5;
    ACKNOWLEDGMENT = 6;
    UPDATE_ANNOUNCEMENT = 7;
    UPDATE_REQUEST = 8;
    UPDATE_CHUNK = 9;
}

// Routing information for multi-hop routing
message RoutingInfo {
    uint32 hop_count = 1;
    uint32 max_hops = 2;
    RouteType route_type = 3;
    optional bytes next_hop = 4;
    optional bytes onion_layers = 5;
}

// Route type enumeration
enum RouteType {
    DIRECT = 0;
    BRIDGE = 1;
    ONION_ROUTED = 2;
}

// Private message payload (encrypted)
message PrivateMessagePayload {
    bytes content = 1;
    bytes return_path = 2;
    bytes ephemeral_public_key = 3;
    bytes nonce = 4;
}

// Broadcast payload (signed, not encrypted)
message BroadcastPayload {
    bytes content = 1;
    string content_type = 2;
    map<string, string> metadata = 3;
}

// Update package (signed by authority)
message UpdatePackage {
    string version = 1;
    bytes package_data = 2;
    string changelog = 3;
    bytes checksum = 4;
    string required_version = 5;
    repeated bytes signatures = 6;
    repeated bytes authority_public_keys = 7;
}

// Query message
message QueryMessage {
    bytes query_id = 1;
    string query_type = 2;
    bytes query_data = 3;
    bool response_required = 4;
    uint32 timeout_ms = 5;
}

// Response message
message ResponseMessage {
    bytes query_id = 1;
    bytes response_data = 2;
    ResponseCode response_code = 3;
}

// Response code enumeration
enum ResponseCode {
    SUCCESS = 0;
    NOT_FOUND = 1;
    ERROR = 2;
    TIMEOUT = 3;
    UNAUTHORIZED = 4;
}

// Route advertisement for route discovery (Phase 4)
message RouteAdvertisement {
    repeated RouteEntry routes = 1;
}

// Route entry submessage
message RouteEntry {
    bytes node_id = 1;
    uint32 hop_count = 2;
    int64 last_seen = 3;
}

// Acknowledgment for reliable delivery (Phase 4)
message Acknowledgment {
    bytes message_id = 1;
    bool success = 2;
    optional string error_message = 3;
}

// Update announcement for update distribution (Phase 5)
message UpdateAnnouncement {
    string version = 1;
    bytes update_id = 2;
    uint64 size = 3;
    bytes checksum = 4;
    repeated bytes signatures = 5;
}

// Update request for update distribution (Phase 5)
message UpdateRequest {
    bytes update_id = 1;
    uint32 chunk_index = 2;
}

// Update chunk for update distribution (Phase 5)
message UpdateChunk {
    bytes update_id = 1;
    uint32 chunk_index = 2;
    uint32 total_chunks = 3;
    bytes data = 4;
    bytes chunk_hash = 5;
}
